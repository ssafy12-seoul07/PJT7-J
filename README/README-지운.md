## PJT7-J

지운

## 시작 전

최종 PJT를 앞두고 있는 상황에서 프론트엔드를 전적으로 담당하게 되었기 때문에,
당분간은 백엔드를 연습할 기회가 부족할 것이라 생각하게 되었음.

현 시점에서 1학기 일정 대부분이 정리되었고, 모든 과정의 내용을 학습했기 때문에 이번 프로젝트는 이전의 프로젝트들보다 부담이 적었기에 Spring Boot백엔드 학습 내용을 점검, 연습하고 개선점 확인을 주 목적으로 두었음.

서로 다른 두 팀의 백엔드 코드를 가져와 합치고 발생하는 문제를 해결하는 방식으로 프로젝트를 진행하려고 했고, 완성된 코드를 합치기만 하면 될 것으로 예상.
때문에 금방 끝날 작업이라고 생각했지만, 각 팀의 설계, 코드에서 차이가 있었으므로 실제로는 예상했던 것보다 큰 작업이 되었음.

## 진행 중

이런 배경때문에 수정할 때 몇 가지 까다로운 점을 확인할 수 있었는데, 각각 이하와 같았음.

1. 일관적, 직관적이지 못한 네이밍
2. 일정에 밀려 급하게 구현한 코드
3. 가독성, 예외 처리, 또는 구조 개선이 가능할 것 같은 코드

### 1. 일관적, 직관적이지 못한 네이밍

적절한 네이밍이 중요하다는 것은 알고 있던 사항이지만, 이번 경우처럼 큰 단위로 작업하는 경우에는 그 중요성이 더욱 크게 다가왔음.

유저 계정 등록, 검증 관련 기능에 사용되는 파일명은 Accounts, User, Auth등으로 혼재되었고, 그렇다면 Accounts, User, Auth마다 다른 기능을 분리해 담당해야 할 것이었지만 실제 코드가 그런 방향으로 구현되어 있지 않았으므로 분리와 통합 중 어떤 방향으로 리팩토링을 진행해야 할지 정하기 어려웠음.

또한 연관 파일들을 쉽게 찾기 힘들어 에러가 발생한다면 해결이 쉽지 않겠다는 느낌을 받았음.

구현 단계에서 네이밍이 혼란스러워 기능 구현에 온전히 집중할 수 없는 상황이 자주 있었기 때문에 네이밍을 적절히 정한다면 기능 구현에 어려움을 덜 겪게 되어 구현에 오히려 적은 시간이 소모될 것.

### 2. 일정에 밀려 급하게 구현한 코드

SSAFY 내에서 진행한 모든 프로젝트는 당일 완성을 목표로 했기 때문에 구현에 많은 시간을 쓸 수는 없었음.

따라서 배운 내용을 단순히 확인, 연습하는 연장선으로써 시행착오를 겪으며 '이렇게 하면 안되겠구나'를 느낄 수 있는 점은 좋았지만, 고민하고 설계, 구현하며 '이렇게 하니까 괜찮은 것 같은데?' 를 확인하기에는 부족했다는 점이 아쉬웠음.

조금이나마 많은 내용을 알게 된 현재 상황에서 이전의 프로젝트를 다시 살펴보는 것은 당시에 미처 생각하지 못했던 것들을 확인하는 신선한 경험이었고, 생각 외로 개선점을 쉽게 발견할 수 있었음.

```xml
<select id="selectOne" parameterType="int" resultType="UserDto">
SELECT * FROM user
WHERE user_id = #{user_id}
</select>
```

```java
    // 로그인
    @PostMapping("/login")
    public ResponseEntity<?> login(@ModelAttribute User user, HttpSession session) {
    	// 현재 로그인 유효성 검증은 입력된 정보로 User객체를 구성하고 객체 내부의 속성을 다시 가져와 비교하는 비효율적인 로직

    	// UserService의 getUser는 유저 정보를 정수형 id 인풋으로 가져오는 구조이며
    	// 백엔드 내에 id를 저장하는 시점이 있다면 db에서 유저 정보를 효율적으로 가져올 수 있겠지만,
    	// 어떤 유저를 검증하게 될지 미리 알 수 없다는 점에서 저장 시점과 위치를 정하기가 어렵고, 필요한지도 의문

    	// 이하 로직에서는 전체 유저 정보를 가져와 각각의 유저 객체 단위로 id, password를 조회하고 있고, session에서도 순회할
    	// 때마다 매번 Attribute를 가져와 조회하고 있음
    	// DB에 등록된 유저 수가 많을 경우 서버가 터질 수도 있을 것 같고, 일시적으로 BE에서 모든 유저 정보에 접근할 수 있게 되기 때문에
    	// 보안 측면에서도 좋지 않을 것 같음

    	// 로그인 시에는 일반적으로 id, password로 유저 정보를 가져올 것이므로,
    	// User객체를 구성해 속성을 또 가져와 비교하는 것보다는 구분가능하고 special한 정보로 DB단에서부터 조회하는 방식이 더 효율적일
    	// 것이라 예상됨
    	// 따라서 리팩토링한다면 BE에서는 최소한의 정보를 이용해 요청하고, DB에서는 정확한 데이터를 찾을 수 있는 최적의 쿼리문을 작성해야 할 것

    	User user = service.getUser(0);

    	// db에서 가져올때부터 하나만 가져오는 방식이 효율적일듯
    	List<User> list = service.getList();
    	for (User u : list) {
    		if (session.getAttribute("loginUser") == null && u.getId().equals(user.getId())
    				&& u.getPassword().equals(user.getPassword())) {
    			session.setAttribute("loginUser", u);
    			System.out.println("login");
    			return new ResponseEntity<>(HttpStatus.OK);
    		}
    	}
    	return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }

```

### 3. 가독성, 예외 처리, 또는 구조 개선이 가능할 것 같은 코드

사용자가 할 수 있는 행동 중 몇 개라도 원하는 대로 동작하지 않는다면 사용자는 이후로 프로그램을 사용하지 않게 될 가능성이 큼.
그러나 사용자의 행동을 모두 예상하기는 어렵기 때문에 사용 가능한 케이스를 가능한 많이 예상해 설계하거나 테스트를 반복해 걸러낼 필요가 있겠지만 그런 점을 완벽히 신경쓰기에 지금은 경험과 실력 모두 부족한 상태.

최근 여러 프로젝트와 실습을 경험하며 예외 처리가 이런 상황을 줄일 수 있는 방법 중 하나임을 실감하게 됨.
모든 상황을 예상하지 못하더라도 기본적인 예외처리 정도만 추가하는 정도로 개발 중에도, 디버깅 중에도 도움이 크게 되고 있음.
문제 발생 시 어느 부분을 확인해야 하는지, 어떤 문제가 생겼는지 확인하기 쉬울 뿐 아니라, 서비스의 어느 한 부분에 문제가 생기더라도 사용자 경험을 크게 해치지 않는 선에서 문제 발생 여부를 알려줄 수 있어 불쾌함을 줄이는 데 도움이 되고 있음.

이외에도 반복되는 부분을 줄이거나 성능 개선을 고려해 추가 기능을 도입할지, 구조 변경으로 해결할지 생각해 보는 것도 도움이 되었음.

## 진행 후

간단하게 끝낼 수 있을 거라 생각했던 프로젝트임에도 예상 외로 많은 부분을 신경써야 했고 덕분에 원래 목표였던 백엔드 구현 연습과 더불어 많은 고민을 할 수 있는 기회가 되었음.
한 분야만 공부했다면 놓치기 쉬웠을 것들을 다시 확인해보게 되어 의미 있는 프로젝트였다고 생각함.

